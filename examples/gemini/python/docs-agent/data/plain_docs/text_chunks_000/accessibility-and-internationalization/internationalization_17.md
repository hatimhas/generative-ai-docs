Putting together an internationalized Flutter app usually
starts with the class that encapsulates the app's localized values.
The example that follows is typical of such classes.
Complete source code for the intl_example for this app.
This example is based on the APIs and tools provided by the
intl package. The An alternative class for the app's
localized resources section
describes an example that doesn't depend on the intl package.
The DemoLocalizations class
(defined in the following code snippet)
contains the app's strings (just one for the example)
translated into the locales that the app supports.
It uses the initializeMessages() function
generated by Dart's intl package,
Intl.message(), to look them up.
code-excerpt "intl_example/lib/main.dart (demo-localizations)"?
```dart
class DemoLocalizations {
  DemoLocalizations(this.localeName);
static Future load(Locale locale) {
    final String name =
        locale.countryCode == null || locale.countryCode!.isEmpty
            ? locale.languageCode
            : locale.toString();
    final String localeName = Intl.canonicalizedLocale(name);
return initializeMessages(localeName).then((_) {
  return DemoLocalizations(localeName);
});

}
static DemoLocalizations of(BuildContext context) {
    return Localizations.of(context, DemoLocalizations)!;
  }
final String localeName;
String get title {
    return Intl.message(
      'Hello World',
      name: 'title',
      desc: 'Title for the Demo application',
      locale: localeName,
    );
  }
}
```
A class based on the intl package imports a generated
message catalog that provides the initializeMessages()
function and the per-locale backing store for Intl.message().
The message catalog is produced by an intl tool
that analyzes the source code for classes that contain
Intl.message() calls.
In this case that would just be the DemoLocalizations class.
